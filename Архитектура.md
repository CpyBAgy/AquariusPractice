# Подробный анализ Selene и PyPOM

## Selene

### Обзор
[Selene](https://github.com/yashaka/selene) - Selene — это лаконичная и мощная библиотека для написания тестов пользовательского интерфейса браузера на Python. Она была создана как порт на Python популярного проекта Selenide из мира Java.

### Ключевые особенности архитектуры

#### 1. Инициализация WebDriver
Selene использует оберточный класс `Browser`, который инкапсулирует WebDriver:
```python
from selene import browser, config

# Конфигурация
config.browser_name = 'chrome'
config.timeout = 10

# Использование
browser.open('https://example.com')
```

#### 2. Обработка WebElement

```python
from selene import browser, be, have

# Находит элемент
browser.element('#username').should(be.visible).type('myuser')

# Проверяет наличие текста в элементе
browser.element('.welcome-message').should(have.text('Welcome, myuser!'))
```

Selene автоматически обрабатывает ожидания для всех операций с элементами.

#### 3. Реализация навигации
Навигация осуществляется через объект `browser`:

```python
from selene import browser

# Простая навигация
browser.open('https://example.com')

# Навигация с базовым URL
browser.config.base_url = 'https://example.com'
browser.open('/login')  # откроет https://example.com/login
```

#### 4. Реализация Page Objects
Selene поддерживает несколько подходов к реализации Page Objects:

Традиционный подход(встроенного нету):
```python
from selene.support.shared import browser
from selene import be, have

class BasePage:
    def __init__(self, browser=browser):
        self.browser = browser

    def open(self, url):
        self.browser.open(url)
        self.wait_for_page_to_load()
        return self

    def wait_for_page_to_load(self):
        return self  # Переопределяется в дочерних классах

class LoginPage(BasePage):
    def __init__(self, browser=browser):
        super().__init__(browser)
        # Хранение только селекторов, без поиска элементов
        self._username_selector = '#username'
        self._password_selector = '#password'
        self._login_button_selector = '#login-button'

    @property
    def username(self):
        return self.browser.element(self._username_selector)

    @property
    def password(self):
        return self.browser.element(self._password_selector)

    @property
    def login_button(self):
        return self.browser.element(self._login_button_selector)

    def open(self):
        return super().open('/login')

    def wait_for_page_to_load(self):
        self.username.should(be.visible)
        return self

    def login(self, username, password):
        self.username.type(username)
        self.password.type(password)
        self.login_button.click()
        return HomePage(self.browser)
```

### Уникальные аспекты Selene

1. **Неявная инициализация элементов**: Элементы инициализируются только при первом обращении (ленивая загрузка).

2. **Условные операции**:
   ```python
   with browser.element('#popup').should(be.visible).should(have.text('Confirm')).perform_if_visible:
       browser.element('#confirm-button').click()
   ```

3. **Удобные предикаты**: `be`, `have` и другие, делающие код более читаемым.

4. **Цепочки команд** для описания пользовательских действий и проверок:
   ```python
   browser.element('#user-table').all('tr').filtered_by(have.text('John')).first.click()
   ```

## PyPOM: Строгий подход от Mozilla

### Обзор
[PyPOM](https://github.com/mozilla/PyPOM) (Python Page Object Model) — фреймворк, разработанный Mozilla для тестирования своих продуктов. Он следует более строгому, структурированному подходу к Page Object Model.

### Ключевые особенности архитектуры

#### 1. Инициализация WebDriver
PyPOM использует явное внедрение зависимостей, передавая WebDriver в конструктор:

```python
from pypom import Page
from selenium.webdriver import Firefox

driver = Firefox()
page = Page(driver, 'https://example.com')
```

#### 2. Обработка WebElement
PyPOM предлагает базовый класс `Region` для представления частей страницы и класс `Page` для представления полных страниц:

```python
from pypom import Page, Region
from selenium.webdriver.common.by import By

class LoginForm(Region):
    _username_locator = (By.ID, 'username')
    _password_locator = (By.ID, 'password')
    _submit_locator = (By.ID, 'submit')

    @property
    def username(self):
        return self.find_element(*self._username_locator)

    @property
    def password(self):
        return self.find_element(*self._password_locator)

    @property
    def submit(self):
        return self.find_element(*self._submit_locator)

    def login(self, username, password):
        self.username.send_keys(username)
        self.password.send_keys(password)
        self.submit.click()
        from pages.home import HomePage
        return HomePage(self.driver)

class LoginPage(Page):
    URL_TEMPLATE = '/login'

    @property
    def login_form(self):
        from regions.login_form import LoginForm
        return LoginForm(self, self.driver.find_element(By.ID, 'login-form'))
```

#### 3. Реализация навигации
PyPOM использует механизм `URL_TEMPLATE` для определения относительных URL:

```python
from pypom import Page

class LoginPage(Page):
    URL_TEMPLATE = '/login'

    def open(self):
        super().open()
        return self

class ProductPage(Page):
    URL_TEMPLATE = '/products/{product_id}'

    def open(self, **kwargs):
        super().open(**kwargs)
        return self

# Использование
login_page = LoginPage(driver, 'https://example.com').open()
product_page = ProductPage(driver, 'https://example.com').open(product_id=123)
```

#### 4. Реализация Page Objects
PyPOM строго следует паттерну Page Object, с четким разделением между страницами и их компонентами:

```python
from pypom import Page, Region
from selenium.webdriver.common.by import By

class HeaderRegion(Region):
    _search_input_locator = (By.ID, 'search')

    def search(self, term):
        search_input = self.find_element(*self._search_input_locator)
        search_input.send_keys(term)
        search_input.submit()
        from pages.search_results import SearchResultsPage
        return SearchResultsPage(self.driver)

class BasePage(Page):
    @property
    def header(self):
        return HeaderRegion(self, self.driver.find_element(By.ID, 'header'))

class HomePage(BasePage):
    URL_TEMPLATE = '/'

    @property
    def loaded(self):
        return self.is_element_displayed(By.CSS_SELECTOR, '.welcome-message')

# Использование
home_page = HomePage(driver, 'https://example.com').open()
search_results = home_page.header.search('test')
```

### Уникальные аспекты PyPOM

1. **Строгая структура**: Четкое разделение на `Page` и `Region`.

2. **Механизм проверки загрузки страницы**: Переопределение свойства `loaded` для каждой страницы:
   ```python
   @property
   def loaded(self):
       return self.is_element_displayed(*self._welcome_message_locator)
   ```

3. **Параметризованные URL**: Поддержка шаблонов URL с подстановкой параметров.

4. **Встроенное ожидание загрузки**: Базовый класс `Page` автоматически проверяет свойство `loaded`.

## Сравнение подходов Selene и PyPOM

### Технические аспекты

| Аспект | Selene | PyPOM |
|--------|--------|-------|
| WebDriver | Оберточный класс Browser | Прямое использование, внедрение через конструктор |
| Элементы | Прокси-объекты (lazy loading) с "умными" ожиданиями | Традиционные методы поиска с явными ожиданиями |
| Ожидания | Встроенные, автоматические | Отдельные методы и свойство `loaded` |
| Структурирование | Гибкое | Строгое, Page и Region |
| Навигация | Через метод browser.open() | Через переопределение URL_TEMPLATE |

### Примеры реализации одинаковой функциональности

#### Поиск продукта

**Selene:**
```python
from selene.support.shared import browser
from selene import be, have

class SearchPage:
    def __init__(self):
        self.search_input = browser.element('#search')
        self.results = browser.all('.product-item')

    def search_for(self, term):
        self.search_input.should(be.visible).clear().type(term).press_enter()
        return self

    def get_first_result(self):
        return self.results.first.text

# Использование
browser.open('https://example.com')
search_page = SearchPage()
result = search_page.search_for('laptop').get_first_result()
```

**PyPOM:**
```python
from pypom import Page
from selenium.webdriver.common.by import By
from selenium.webdriver.common.keys import Keys

class SearchPage(Page):
    URL_TEMPLATE = '/search'

    _search_input_locator = (By.ID, 'search')
    _results_locator = (By.CSS_SELECTOR, '.product-item')

    @property
    def loaded(self):
        return self.is_element_displayed(*self._search_input_locator)

    def search_for(self, term):
        search_input = self.find_element(*self._search_input_locator)
        search_input.clear()
        search_input.send_keys(term)
        search_input.send_keys(Keys.RETURN)
        return self

    def get_first_result(self):
        results = self.find_elements(*self._results_locator)
        if results:
            return results[0].text
        return None

# Использование
driver.get('https://example.com')
search_page = SearchPage(driver)
result = search_page.search_for('laptop').get_first_result()
```